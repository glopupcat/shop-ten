# Slug vs ID — почему нужен slug и как правильно его использовать

Этот документ объясняет, зачем в URL использовать «slug» (читаемый человеко‑дружественный идентификатор) в дополнение к или вместо внутреннего id, какие есть подходы, подводные камни и практические рекомендации для разработки и продакшна.

## Кратко: что такое id и slug
- id — внутренний уникальный идентификатор сущности (например `paint-p1`, UUID и т.п.). Хорош для надёжных и однозначных запросов к БД.
- slug — человекочитаемая часть URL, обычно основана на title (например `interior-eggshell-pure-white-1gal`). Лучше для SEO, удобного шаринга и пользовательских ссылок.

## Почему использовать slug
- SEO и CTR: slug может содержать ключевые слова (бренд, тип, цвет), что полезно для поисковой выдачи.
- UX: пользователи и маркетологи читают и понимают ссылку без открытия.
- Social sharing: выглядит корректно в мессенджерах и социальных сетях.

## Почему оставить id (не только slug)
- стабильность: slug может меняться (редактирование title), id — более стабильный ключ.
- однозначность: slug может совпадать, нужно поддерживать уникальность; id гарантирован уникален.
- внутренние связи: многие сервисы/интеграции проще привязывать по id.

## Подходы к маршрутизации (common patterns)
1. Только id
   - URL: `/product/{id}`
   - + просто реализуется, всегда уникально
   - − нечитабельно, хуже для SEO

2. Только slug
   - URL: `/product/{slug}`
   - + отличный SEO/UX
   - − нужно гарантировать уникальность и поддерживать редиректы при смене slug

3. Гибрид (рекомендуется для миграции/надёжности)
   - URL: `/product/{id}-{slug}` или `/product/{id}/{slug}`
   - + можно быстро найти по id, slug остаётся для SEO; при смене slug ссылка остаётся валидной
   - − чуть более длинные URL, но безопаснее при изменениях

## Как мы решили в проекте (что уже реализовано)
- Фро��тенд сначала запрашивает продукт по сегменту пути как по id (GET `/api/products/:id`).
- Если продукт не найден, фронтенд делает fallback и пытаетcя найти по slug (ProductsAPI.getProductBySlug).
- Также в роут‑shim добавлен server‑safe useParams и логика, которая пытается корректно вытащить `id`/`slug` из URL в браузере.

Это даёт поддержку обоих форм URL без необходимости менять API и минимизирует 404 при старых ссылках.

## Рекомендации для админки
- В форме продукта должен быть отдельный `slug`-поле, editable и auto‑generated из title (e.g. `toLowerCase()`, заменять пробелы на `-`, удалять опасные символы).
- Валидируйте уникальность slug при сохранении (сервер‑side). Показать предупреждение, если slug занят.
- Если slug меняется, сохраняйте старые slug в таблицу `previous_slugs` и делайте 301 редирект с old → new (важно для SEO).

## API и бэкенд: что сделать на будущее
- Реализовать отдельный endpoint GET `/products/slug/:slug` (быстрая и однозначная точка), либо расширить `GET /products/:idOrSlug` со спробованием поиска сначала по id, затем по slug (как fallback).
- Индексировать slug в БД (unique index) для производительности.
- Хранить историю slug (previous_slugs) чтобы обрабатывать старые внешние ссылки и делать 301 редиректы.

## SEO и каноникализация
- Встраивайте canonical `<link rel="canonical" href="https://example.com/product/{canonical-url}" />` на странице продукта.
- Если поддерживаете оба URL (slug-only и id-hybrid), выберите одну форму как canonical и редиректьте вторую на неё (301).

## Тонкие места и нюансы
- Кодировка: корректно обрабатывайте UTF‑8, избегайте пробелов и специальных символов в slug.
- Длина: ограничьте slug (например 100‑200 символов) и обрезайте аккуратно.
- Локализация: для мульти‑язычных сайтов можно иметь slug per locale (`/en/...`, `/es/...`) и учесть это в таблице canonical/redirects.
- Дубликаты: при auto‑генерации slug, добавляйте числовой суффикс при конфликте (`-1`, `-2`).

## Примеры URL и поведения
- `/product/paint-p1` — id-based (коротко, всегда найдёт по id)
- `/product/interior-eggshell-pure-white-1gal` — slug-based (читаемо)
- `/product/paint-p1-interior-eggshell-pure-white-1gal` — гибрид (лучший компромисс)

## Что рекомендую для production
- Для публичного сайта (production) — использовать гибридную форму (`{id}-{slug}`) или slug‑only с надёжной системой редиректов и историей slug. Гибрид проще реализовать и надёжен при изменениях.
- Всегда ставьте canonical URL и 301 редиректы при смене slug.
- Индексируйте slug в БД и добавьте покрывающие индексы для производительности.

## Дальнейшие ��аги (короткий план внедрения)
1. В API добавить endpoint для поиска по slug (или поддержать универсальный параметр).  
2. В админке: auto‑generate slug, валидация уникальности, история старых slug.  
3. Настроить 301 редиректы на бэкенде (использовать таблицу previous_slugs).  
4. Обновить sitemap.xml и canonical URLs.  

Если хотите, я могу автоматически добавить API endpoint `GET /products/slug/:slug` на бэкенд и обновить админскую форму для авто‑генерации slug и проверки уникальности. Скажите, хотите ли сразу реализовать это покрытие.
